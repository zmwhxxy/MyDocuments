{"id":"01hdbcqtbnp3xxp9jw0wjbb3gq","item_id":"01hdbcfvynjc8vhtmqhsfr5pzs","add_time_ms":1697968286069,"hash":"e56bf666d9ec46028fc7bee78a22ef97","full_content":"# cmake : add_library详解\nadd_library是写cmake必备的一个函数，但一直没仔细研究过，今天把它折解下。主要参考\ncmake官方文档\n\n## normal library\nadd_library(<name> [STATIC | SHARED | MODULE]\n            [EXCLUDE_FROM_ALL]\n            [source1] [source2 ...])\n添加名为name的库，库的源文件可指定，也可用target_sources()后续指定。\n库的类型是STATIC(静态库)/SHARED(动态库)/MODULE(模块库)之一。\n\nname属性必须全局唯一\n生成的library名会根据STATIC或SHARED成为name.a或name.lib\n这里的STATIC和SHARED可不设置，通过全局的BUILD_SHARED_LIBS的FALSE或TRUE来指定\nwindows下，如果dll没有export任何信息，则不能使用SHARED，要标识为MODULE\n\n添加的库会被输出到以下几个目录\nARCHIVE_OUTPUT_DIRECTORY, LIBRARY_OUTPUT_DIRECTORY和 RUNTIME_OUTPUT_DIRECTORY，详见cmake 常用设定及函数\n设置EXCLUDE_FROM_ALL，可使这个library排除在all之外，即必须明确点击生成才会生成\n\nimported library\nadd_library(<name> <SHARED|STATIC|MODULE|OBJECT|UNKNOWN> IMPORTED\n            [GLOBAL])\n这种用法直接导入已经生成的库，cmake不会给这类library添加编译规则。\n这种用法的关键在于添加变量IMPORTED。\n另外，GLOBAL可用于设置这个library为全局可见。\n常规和imported的library的属性不同：\n\n常规的library，其属性以INTERFACE_开头\nimported的library，其属性以IMPORTED_开头\nINTERFACE_和IMPORTED_开头的变量有哪些，参见interface libraries，还需再研究。\n\nimported的library最重要的几个属性是：\n\nIMPORTED_LOCATION:标明library在硬盘上的位置，可以用更具体的IMPORTED_LOCATION_<CONFIG>的标注，其中的<CONFIG>可以是DEBUG/RELEASE或其他\nIMPORTED_OBJECTS：标明对象library在硬盘上的位置，相应的有IMPORTED_OBJECTS_<CONFIG>来标识具体编译类型\nPUBLIC_HEADER：如果install这个library的话，这个值保存头文件的目录\nUNKNOWN类型，在不需要明确library类型时使用。\n\nobject library\nadd_library(<name> OBJECT <src>...)\n库的类型固定为OBJECT，这种库编译了源文件，但不链接。实际中没用过，没有仔细研究。使用方法：\n\nadd_library(... $<TARGET_OBJECTS:objlib> ...)\nadd_executable(... $<TARGET_OBJECTS:objlib> ...)\nalias library（别名库）\n为给定library添加一个别名，后续可使用<name>来替代<target>。\n\nadd_library(<name> ALIAS <target>)\n使用有如下限制：\n\n<target>不能是ALIAS\n可用于判断target是否存在、链接。\nALIAS的library不能修改属性，不能调用set_property(), set_target_properties()和target_link_libraries()等方法\n不能用于install()\ninterface library\n创建一个接口库，\n\nadd_library(<name> INTERFACE [IMPORTED [GLOBAL]])\n这类库有属性，能install()，export和imported，但可能没有build过程。像纯头文件库或完全针对target的设计（这条参见interface libraries）\n所有INTERFACE _*属性从如下几个方法中设置\nset_property()、target_link_libraries(INTERFACE)、target_link_options(INTERFACE)、target_include_directories(INTERFACE)、target_compile_options(INTERFACE)、target_compile_definitions(INTERFACE)和target_sources(INTERFACE)。\n\n手工配置库\n参考 cmake引入外部库\n\n静态库\n\nadd_library(baz STATIC IMPORTED)\nset_target_properties(baz PROPERTIES\nIMPORTED_LOCATION_RELEASE ${CMAKE_CURRENT_SOURCE_DIR}/libbaz.a\nIMPORTED_LOCATION_DEBUG ${CMAKE_CURRENT_SOURCE_DIR}/libbazd.a)\n静态库(添加依赖项)\n\nadd_library(bar STATIC IMPORTED)\nset_target_properties(bar PROPERTIES\nIMPORTED_LOCATION_RELEASE ${CMAKE_CURRENT_SOURCE_DIR}/libbar.a\nIMPORTED_LOCATION_DEBUG ${CMAKE_CURRENT_SOURCE_DIR}/libbard.a\nIMPORTED_LINK_INTERFACE_LIBRARIES baz) # <-- dependency is here\n动态库\n\nadd_library(bar SHARED IMPORTED)\nset_property(TARGET bar PROPERTY IMPORTED_LOCATION c:/path/to/bar.dll)\nset_property(TARGET bar PROPERTY IMPORTED_IMPLIB c:/path/to/bar.lib) # 多了lib信息\nadd_executable(myexe src1.c src2.c)\ntarget_link_libraries(myexe bar)\n当然，也可以直接引用库文件\n\nTARGET_LINK_LIBRARIES(skiaSampleCode\ndebug skiaCored.lib\noptimized skiaCore.lib)","_id":"60"}