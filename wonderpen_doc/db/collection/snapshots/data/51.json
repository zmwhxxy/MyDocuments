{"id":"01hd9bryf27myt8kczqr9etvk0","item_id":"01hd9709pz4kayzhh221czresy","add_time_ms":1697900165602,"hash":"796b30b2e279caa95b0d3120eaa883b0","full_content":"## 混合静态和共享\n在本节,我们会展示`BUILD_SHARED_LIBS`变量是怎么样用于控制`add_library()`的表现.并且容许控制没有显式类型(`STATIC`, `SHARED` `MODULE`或者`OBJECT`)的库的构建.\n\n我们需要在顶级`CMakeLists.txt`里增加`BUILD_SHARED_LIBS`.我们用`option()`命令来让用户可以选开或者关.\n\n下一步我们要重构MathFunctions来使其成为一个封装了调用`mysqrt`或者`sqrt`的真实的库,而非需要调用代码来实现这个逻辑.这也意味着`USE_MYMATH`不再控制构建MathFunctions而是控制库的行为.\n\n第一步是更新顶级`CMakeLists.txt`的第一节如下:\n\n```CMake\ncmake_minimum_required(VERSION 3.10)\n\n# set the project name and version\nproject(Tutorial VERSION 1.0)\n\n# specify the C++ standard\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\n\n# control where the static and shared libraries are built so that on windows\n# we don't need to tinker with the path to run the executable\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \"${PROJECT_BINARY_DIR}\")\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY \"${PROJECT_BINARY_DIR}\")\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY \"${PROJECT_BINARY_DIR}\")\n\noption(BUILD_SHARED_LIBS \"Build using shared libraries\" ON)\n\n# configure a header file to pass the version number only\nconfigure_file(TutorialConfig.h.in TutorialConfig.h)\n\n# add the MathFunctions library\nadd_subdirectory(MathFunctions)\n\n# add the executable\nadd_executable(Tutorial tutorial.cxx)\ntarget_link_libraries(Tutorial PUBLIC MathFunctions)\n```\n\n既然我们已经让MathFunctions总被使用.我们需要更新库的逻辑.因此在`MathFunctions/CMakeLists.txt`里我们需要建立一个SqrtLibrary.这个库会在`USE_MYMATH`启用的条件下构建并安装.现在,因为这只是一篇教程,我们显式地要求SqrtLibrary构建为静态库就可以了.\n\n结果是`MathFunctions/CMakeLists.txt`应该如下:\n\n```CMake\n# add the library that runs\nadd_library(MathFunctions MathFunctions.cxx)\n\n# state that anybody linking to us needs to include the current source dir\n# to find MathFunctions.h, while we don't.\ntarget_include_directories(MathFunctions\n                           INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}\n                           )\n\n# should we use our own math functions\noption(USE_MYMATH \"Use tutorial provided math implementation\" ON)\nif(USE_MYMATH)\n\n  target_compile_definitions(MathFunctions PRIVATE \"USE_MYMATH\")\n\n  # first we add the executable that generates the table\n  add_executable(MakeTable MakeTable.cxx)\n\n  # add the command to generate the source code\n  add_custom_command(\n    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n    COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n    DEPENDS MakeTable\n    )\n\n  # library that just does sqrt\n  add_library(SqrtLibrary STATIC\n              mysqrt.cxx\n              ${CMAKE_CURRENT_BINARY_DIR}/Table.h\n              )\n\n  # state that we depend on our binary dir to find Table.h\n  target_include_directories(SqrtLibrary PRIVATE\n                             ${CMAKE_CURRENT_BINARY_DIR}\n                             )\n\n  target_link_libraries(MathFunctions PRIVATE SqrtLibrary)\nendif()\n\n# define the symbol stating we are using the declspec(dllexport) when\n# building on windows\ntarget_compile_definitions(MathFunctions PRIVATE \"EXPORTING_MYMATH\")\n\n# install rules\nset(installable_libs MathFunctions)\nif(TARGET SqrtLibrary)\n  list(APPEND installable_libs SqrtLibrary)\nendif()\ninstall(TARGETS ${installable_libs} DESTINATION lib)\ninstall(FILES MathFunctions.h DESTINATION include)\n```\n\n下一步更新`MathFunctions/mysqrt.cxx`以使用`mathfunctions`和`detail`命名空间:\n\n```C++\n#include <iostream>\n\n#include \"MathFunctions.h\"\n\n// include the generated table\n#include \"Table.h\"\n\nnamespace mathfunctions {\nnamespace detail {\n// a hack square root calculation using simple operations\ndouble mysqrt(double x)\n{\n  if (x <= 0) {\n    return 0;\n  }\n\n  // use the table to help find an initial value\n  double result = x;\n  if (x >= 1 && x < 10) {\n    std::cout << \"Use the table to help find an initial value \" << std::endl;\n    result = sqrtTable[static_cast<int>(x)];\n  }\n\n  // do ten iterations\n  for (int i = 0; i < 10; ++i) {\n    if (result <= 0) {\n      result = 0.1;\n    }\n    double delta = x - (result * result);\n    result = result + 0.5 * delta / result;\n    std::cout << \"Computing sqrt of \" << x << \" to be \" << result << std::endl;\n  }\n\n  return result;\n}\n}\n}\n```\n\n我们也需要在`tutorial.cxx`中进行调整,所有不再使用`USE_MYMATH`:\n\n1. 总是包含`MathFunctions.h`\n2. 总是使用`mathfunctions::sqrt`\n3. 不包含cmath\n\n最后更新`MathFunctions/MathFunctions.h`来用dll导出定义:\n\n```C++\n#if defined(_WIN32)\n#  if defined(EXPORTING_MYMATH)\n#    define DECLSPEC __declspec(dllexport)\n#  else\n#    define DECLSPEC __declspec(dllimport)\n#  endif\n#else // non windows\n#  define DECLSPEC\n#endif\n\nnamespace mathfunctions {\ndouble DECLSPEC sqrt(double x);\n}\n```\n\n这时,如果你构建任何东西,可能会注意到链接失败,因为我们在试图将一个不包含位置无关代码(PIC)（译者注：指生成的代码中无绝对跳转指令，跳转都为相对跳转，详见[维基百科](https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81)）的静态库（译者注：指`SqrtLibrary`）和另一个包含位置无关代码(PIC)的库（译者注：指`MathFunctions`）组合在一起.解决方案是显式地将SqrtLibrary的`POSITION_INDEPENDENT_CODE`目标属性设定为True,不管是什么构建类型.\n\n```CMake\n  # state that SqrtLibrary need PIC when the default is shared libraries\n  set_target_properties(SqrtLibrary PROPERTIES\n                        POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS}\n                        )\n\n  target_link_libraries(MathFunctions PRIVATE SqrtLibrary)\n```\n\n**练习**: 我们修改`MathFunctions.h`来使用dll导出定义.使用CMake文档你能否招到一个辅助模块来简化么?","_id":"51"}