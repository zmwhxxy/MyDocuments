{"id":"01hdbda4dta05eb7hewd5mzhvg","item_id":"01hdbcfvynjc8vhtmqhsfr5pzs","add_time_ms":1697968886202,"hash":"8e4e04ed9c62e6788d2da89cf823ff9c","full_content":"# cmake : add_library详解\n\n　　add_library是写cmake必备的一个函数，但一直没仔细研究过，今天把它折解下。主要参考\n\n　　cmake官方文档\n\n## normal library\n\n　　add_library(<name> [STATIC | SHARED | MODULE]\n\n　　[EXCLUDE_FROM_ALL]\n\n　　[source1] [source2 ...])\n\n　　添加名为name的库，库的源文件可指定，也可用target_sources()后续指定。\n\n　　库的类型是STATIC(静态库)/SHARED(动态库)/MODULE(模块库)之一。\n\n　　name属性必须全局唯一\n\n　　生成的library名会根据STATIC或SHARED成为name.a或name.lib\n\n　　这里的STATIC和SHARED可不设置，通过全局的BUILD_SHARED_LIBS的FALSE或TRUE来指定\n\n　　windows下，如果dll没有export任何信息，则不能使用SHARED，要标识为MODULE\n\n　　添加的库会被输出到以下几个目录\n\n　　ARCHIVE_OUTPUT_DIRECTORY, LIBRARY_OUTPUT_DIRECTORY和 RUNTIME_OUTPUT_DIRECTORY，详见cmake 常用设定及函数\n\n　　设置EXCLUDE_FROM_ALL，可使这个library排除在all之外，即必须明确点击生成才会生成\n\n## imported library\n\n　　add_library(<name> <SHARED|STATIC|MODULE|OBJECT|UNKNOWN> IMPORTED\n\n　　[GLOBAL])\n\n　　这种用法直接导入已经生成的库，cmake不会给这类library添加编译规则。\n\n　　这种用法的关键在于添加变量IMPORTED。\n\n　　另外，GLOBAL可用于设置这个library为全局可见。\n\n　　常规和imported的library的属性不同：\n\n　　常规的library，其属性以INTERFACE_开头\n\n　　imported的library，其属性以IMPORTED_开头\n\n　　INTERFACE_和IMPORTED_开头的变量有哪些，参见interface libraries，还需再研究。\n\n　　imported的library最重要的几个属性是：\n\n　　IMPORTED_LOCATION:标明library在硬盘上的位置，可以用更具体的IMPORTED_LOCATION_<CONFIG>的标注，其中的<CONFIG>可以是DEBUG/RELEASE或其他\n\n　　IMPORTED_OBJECTS：标明对象library在硬盘上的位置，相应的有IMPORTED_OBJECTS_<CONFIG>来标识具体编译类型\n\n　　PUBLIC_HEADER：如果install这个library的话，这个值保存头文件的目录\n\n　　UNKNOWN类型，在不需要明确library类型时使用。\n\n## object library\n\n　　add_library(<name> OBJECT <src>...)\n\n　　库的类型固定为OBJECT，这种库编译了源文件，但不链接。实际中没用过，没有仔细研究。使用方法：\n\n　　add_library(... $<TARGET_OBJECTS:objlib> ...)\n\n　　add_executable(... $<TARGET_OBJECTS:objlib> ...)\n\n## alias library（别名库）\n\n　　为给定library添加一个别名，后续可使用<name>来替代<target>。\n\n　　add_library(<name> ALIAS <target>)\n\n　　使用有如下限制：\n\n<target>不能是ALIAS\n\n　　可用于判断target是否存在、链接。\n\n　　ALIAS的library不能修改属性，不能调用set_property(), set_target_properties()和target_link_libraries()等方法\n\n　　不能用于install()\n\n## interface library\n\n　　创建一个接口库，\n\n　　add_library(<name> INTERFACE [IMPORTED [GLOBAL]])\n\n　　这类库有属性，能install()，export和imported，但可能没有build过程。像纯头文件库或完全针对target的设计（这条参见interface libraries）\n\n　　所有INTERFACE _*属性从如下几个方法中设置\n\n　　set_property()、target_link_libraries(INTERFACE)、target_link_options(INTERFACE)、target_include_directories(INTERFACE)、target_compile_options(INTERFACE)、target_compile_definitions(INTERFACE)和target_sources(INTERFACE)。\n\n# 手工配置库\n\n　　参考 cmake引入外部库\n\n## 静态库\n\n　　add_library(baz STATIC IMPORTED)\n\n　　set_target_properties(baz PROPERTIES\n\n　　IMPORTED_LOCATION_RELEASE ${CMAKE_CURRENT_SOURCE_DIR}/libbaz.a\n\n　　IMPORTED_LOCATION_DEBUG ${CMAKE_CURRENT_SOURCE_DIR}/libbazd.a)\n\n　　静态库(添加依赖项)\n\n　　add_library(bar STATIC IMPORTED)\n\n　　set_target_properties(bar PROPERTIES\n\n　　IMPORTED_LOCATION_RELEASE ${CMAKE_CURRENT_SOURCE_DIR}/libbar.a\n\n　　IMPORTED_LOCATION_DEBUG ${CMAKE_CURRENT_SOURCE_DIR}/libbard.a\n\n　　IMPORTED_LINK_INTERFACE_LIBRARIES baz) # <-- dependency is here\n\n## 动态库\n\n　　add_library(bar SHARED IMPORTED)\n\n　　set_property(TARGET bar PROPERTY IMPORTED_LOCATION c:/path/to/bar.dll)\n\n　　set_property(TARGET bar PROPERTY IMPORTED_IMPLIB c:/path/to/bar.lib) # 多了lib信息\n\n　　add_executable(myexe src1.c src2.c)\n\n　　target_link_libraries(myexe bar)\n\n　　当然，也可以直接引用库文件\n\n　　TARGET_LINK_LIBRARIES(skiaSampleCode\n\n　　debug skiaCored.lib\n\n　　optimized skiaCore.lib)","_id":"61"}