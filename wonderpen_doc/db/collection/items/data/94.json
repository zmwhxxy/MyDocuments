{"id":"01hdbw4fmj8d5fjtt7ax3514fh","add_time_ms":1697984429714,"icon":"book","type":"doc","title":"file","_id":"94","char_count":{"word":9325,"char_without_spaces":17031,"char_with_spaces":19086,"char_all":20260},"content":"# file\n    \n### 常用方法:\n            file(GLOB_RECURSE var root_dir/*.cpp) (递归root_dir目录及子目录下的源文件保存到变量var)\n    \n　　file（读取<文件名> <可变> [偏移量<偏移量>] [限制<最大输入>] [十六进制]）\n\n　　从调用的文件中读取内容并将其存储在 .可选地从给定的和 最多读取字节。该选项会导致数\n\n　　据 转换为十六进制表示形式（对二进制数据有用）。 如果指定了该选项，则输出中的字母\n\n　　（ 到 ） 为小写。<filename><variable><offset><max-in>HEXHEXaf\n\n　　文件（字符串 <文件名> <变量> [<选项>...]）\n\n　　解析 中的 ASCII 字符串列表并将其存储在 中。文件中的二进制数据将被忽略。回车 （、\n\n　　CR） 字符将被忽略。选项包括：<filename><variable>\\r\n\n　　LENGTH_MAXIMUM <max-len>\n\n　　仅考虑最多给定长度的字符串。\n\n　　LENGTH_MINIMUM <min-len>\n\n　　仅考虑至少给定长度的字符串。\n\n　　LIMIT_COUNT <max-num>\n\n　　限制要提取的不同字符串的数量。\n\n　　LIMIT_INPUT <max-in>\n\n　　限制要从文件中读取的输入字节数。\n\n　　LIMIT_OUTPUT <max-out>\n\n　　限制要存储在 中的总字节数。<variable>\n\n　　NEWLINE_CONSUME\n\n　　将换行符 （， LF） 视为字符串内容的一部分 而不是终止于他们。\\n\n\n　　NO_HEX_CONVERSION\n\n　　英特尔十六进制和摩托罗拉 S 记录文件自动转换为 读取时二进制，除非给出此选\n\n　　项。\n\n　　REGEX <regex>\n\n　　仅考虑与给定正则表达式匹配的字符串， 如字符串（正则表达式）中所述。\n\n　　ENCODING <encoding-type>\n\n　　版本 3.1 中的新功能。\n\n　　考虑给定编码的字符串。当前支持的编码有：、、、、。 如果未提供该选项并且文\n\n　　件 有一个字节顺序标记，该选项将是默认的 尊重字节顺序标记。UTF-8UTF\u000216LEUTF-16BEUTF-32LEUTF-32BEENCODINGENCODING\n\n　　版本 3.2 中的新功能： 添加了 、 、 编码。UTF-16LEUTF-16BEUTF-32LEUTF-32BE\n\n　　例如，代码\n\n　　file(STRINGS myfile.txt myfile)\n\n　　在变量中存储一个列表，其中每个项目都是一行 从输入文件。myfile\n\n　　file（<哈希> <文件名> <变量>）¶\n\n　　计算 和 的内容的加密哈希 将其存储在 .支持的算法名称 是命令列出的那些。<filename>\n\n<variable><HASH>\n\n　　文件（时间戳 <文件名> <变量> [<格式>] [UTC]）¶\n\n　　计算 的修改时间的字符串表示形式并将其存储在 中。如果命令无法获取 时间戳变量将设置\n\n　　为空字符串 （“”）。<filename><variable>\n\n　　有关文档，请参阅命令 和选项。<format>UTC\n\n　　文件（GET_RUNTIME_DEPENDENCIES [...]）¶\n\n　　版本 3.16 中的新功能。\n\n　　递归获取给定文件所依赖的库列表：\n\n　　file(GET_RUNTIME_DEPENDENCIES\n\n　　[RESOLVED_DEPENDENCIES_VAR <deps_var>]\n\n　　[UNRESOLVED_DEPENDENCIES_VAR <unresolved_deps_var>]\n\n　　[CONFLICTING_DEPENDENCIES_PREFIX <conflicting_deps_prefix>]\n\n　　[EXECUTABLES [<executable_files>...]]\n\n　　[LIBRARIES [<library_files>...]]\n\n　　[MODULES [<module_files>...]]\n\n　　[DIRECTORIES [<directories>...]]\n\n　　[BUNDLE_EXECUTABLE <bundle_executable_file>]\n\n　　[PRE_INCLUDE_REGEXES [<regexes>...]]\n\n　　[PRE_EXCLUDE_REGEXES [<regexes>...]]\n\n　　[POST_INCLUDE_REGEXES [<regexes>...]]\n\n　　[POST_EXCLUDE_REGEXES [<regexes>...]]\n\n　　[POST_INCLUDE_FILES [<files>...]]\n\n　　[POST_EXCLUDE_FILES [<files>...]]\n\n　　)\n\n　　请注意，此子命令不适用于项目模式。 它旨在用于安装时，无论是从命令生成的代码，还\n\n　　是从 通过 或 的项目。 例如：\n\n　　install(CODE [[\n\n　　file(GET_RUNTIME_DEPENDENCIES\n\n# ...\n\n　　)\n\n　　]])\n\n　　参数如下：\n\n　　RESOLVED_DEPENDENCIES_VAR <deps_var>\n\n　　要在其中存储已解析依赖项列表的变量的名称。\n\n　　UNRESOLVED_DEPENDENCIES_VAR <unresolved_deps_var>\n\n　　要在其中存储未解析列表的变量的名称 依赖。如果未指定此变量，并且存在任何 未\n\n　　解析的依赖项，则发出错误。\n\n　　CONFLICTING_DEPENDENCIES_PREFIX <conflicting_deps_prefix>\n\n　　用于存储冲突依赖项信息的变量前缀。 如果在 中找到两个同名的文件，则依赖项冲\n\n　　突 两个不同的目录。存储冲突的文件名列表 在。对于每个文件名，列表 为该文件名\n\n　　找到的路径存储在 中。\n\n<conflicting_deps_prefix>_FILENAMES<conflicting_deps_prefix>_<filename>\n\n　　EXECUTABLES <executable_files>\n\n　　要读取依赖项的可执行文件列表。这些是可执行文件 通常使用 创建，但它们确实如\n\n　　此 不必由CMake创建。在苹果平台上，这些的途径 文件确定递归时的值 解析库。\n\n　　在此处指定任何类型的库 （、 或 ） 将导致未定义的行为。\n\n　　@executable_pathSTATICMODULESHARED\n\n　　LIBRARIES <library_files>\n\n　　要读取依赖项的库文件列表。这些是库 通常使用 创建，但它们确实如此 不必由\n\n　　CMake创建。在此处指定库、库或可执行文件将导致未定义 行为。STATICMODULE\n\n　　MODULES <module_files>\n\n　　要读取依赖项的可加载模块文件的列表。这些是模块 通常使用 创建，但它们 不必由\n\n　　CMake创建。它们通常通过在运行时调用来使用，而不是在链接时与 链接。 指定\n\n　　库、库或可执行文件 这将导致未定义的行为。dlopen()ld -lSTATICSHARED\n\n　　DIRECTORIES <directories>\n\n　　要搜索依赖项的其他目录的列表。在 Linux 上 平台，如果未找到依赖项，则搜索这\n\n　　些目录 在任何其他常用路径中。如果在这样的目录中找到它，则 发出警告，因为这\n\n　　意味着文件不完整（确实如此） 不列出包含其依赖项的所有目录）。 在 Windows\n\n　　平台上，如果依赖项 在任何其他搜索路径中都找不到，但不会发出警告， 因为搜索\n\n　　其他路径是 Windows 依赖项的正常部分 分辨率。在苹果平台上，这种说法是无效\n\n　　的。\n\n　　BUNDLE_EXECUTABLE <bundle_executable_file>\n\n　　在解析库时视为“捆绑可执行文件”的可执行文件。 在 Apple 平台上，此参数确定\n\n　　递归解析 和 文件的库时的值。它对文件没有影响。在其他平台上，它不起作用。这\n\n　　通常是（但不是 总是）参数中的可执行文件之一 指定包的“主”可执行文件。\n\n　　@executable_pathLIBRARIESMODULESEXECUTABLESEXECUTABLES\n\n　　以下参数指定用于包含或排除库的筛选器 待解决。有关其工作原理的完整说明，请参见下\n\n　　文。\n\n　　PRE_INCLUDE_REGEXES <regexes>\n\n　　预包含正则表达式列表，通过这些正则表达式来过滤 尚未解决的依赖项。\n\n　　PRE_EXCLUDE_REGEXES <regexes>\n\n　　预排除正则表达式列表，通过这些正则表达式来筛选 尚未解决的依赖项。\n\n　　POST_INCLUDE_REGEXES <regexes>\n\n　　包含后正则表达式列表，通过这些正则表达式来过滤 已解决的依赖项。\n\n　　POST_EXCLUDE_REGEXES <regexes>\n\n　　排除后正则表达式列表，通过这些列表来过滤 已解决的依赖项。\n\n　　POST_INCLUDE_FILES <files>\n\n　　版本 3.21 中的新功能。\n\n　　用于筛选 名称的包含后文件名列表 已解决的依赖项。尝试匹配时解析符号链接 这些\n\n　　文件名。\n\n　　POST_EXCLUDE_FILES <files>\n\n　　版本 3.21 中的新功能。\n\n　　排除后文件名列表，通过该文件名筛选 已解决的依赖项。尝试匹配时解析符号链接\n\n　　这些文件名。\n\n　　在以下情况下，这些参数可用于排除不需要的系统库 解析依赖项，或包含来自特定 目录。\n\n　　筛选工作原理如下：\n\n1. 如果尚未解析的依赖项与 中的任何一个匹配，则跳过步骤 2 和 3，并且依赖项\n\n　　解决方案继续执行步骤 4。PRE_INCLUDE_REGEXES\n\n2. 如果尚未解析的依赖项与任何 匹配，则依赖项解析将停止该依赖项。\n\n　　PRE_EXCLUDE_REGEXES\n\n3. 否则，依赖项解析将继续。\n4. file(GET_RUNTIME_DEPENDENCIES)搜索依赖项依据 到平台的链接规则（见下文）。\n5. 如果找到依赖项，并且其完整路径与 or 之一匹配，则添加完整路径 到解析的依\n\n　　赖项，并递归解析该库自己的依赖项。否则，分辨率 继续执行步骤 6。\n\n　　POST_INCLUDE_REGEXESPOST_INCLUDE_FILESfile(GET_RUNTIME_DEPENDENCIES)\n\n6. 如果找到依赖项，但其完整路径与 or 之一匹配，则不会将其添加到 已解析的依\n\n　　赖项，并且依赖项解析将停止该依赖项。POST_EXCLUDE_REGEXESPOST_EXCLUDE_FILES\n\n7. 如果找到依赖项，并且其完整路径不匹配、、、 或 ，将完整路径添加到已解析\n\n　　的 依赖关系，并递归解析 该库自己的依赖项。\n\n　　POST_INCLUDE_REGEXESPOST_INCLUDE_FILESPOST_EXCLUDE_REGEXESPOST_EXCLUDE_FILESfile\n\n　　(GET_RUNTIME_DEPENDENCIES)\n\n　　不同的平台对如何解析依赖项有不同的规则。 此处介绍了这些细节。\n\n　　在 Linux 平台上，库解析的工作方式如下：\n\n1. 如果依赖文件没有任何条目，并且 库存在于依赖文件的条目之一中，或者其 父\n\n　　级“，按该顺序将依赖项解析为该文件。RUNPATHRPATH\n\n2. 否则，如果依赖文件有任何条目，并且 库存在于其中一个条目中，依赖项解析为\n\n　　该条目 文件。RUNPATH\n\n3. 否则，如果库存在于 列出的目录之一中，则依赖项将解析为该文件。ldconfig\n4. 否则，如果库存在于其中一个条目中， 依赖项将解析为该文件。在这种情况下，\n\n　　警告是 发出，因为在其中一个中查找文件意味着 依赖文件不完整（它没有列出\n\n　　所有目录 它从中提取依赖项）。DIRECTORIESDIRECTORIES\n\n5. 否则，依赖项将无法解析。\n\n　　在 Windows 平台上，库解析的工作方式如下：\n\n1. DLL 依赖项名称将转换为小写，以便匹配筛选器。 Windows DLL 名称不区分大\n\n　　小写，并且某些链接器会破坏 DLL 依赖项名称的大小写。但是，这使得它更加困\n\n　　难 为 、 、 和 正确 过滤器 DLL 名称 - 每个正则表达式都必须检查两个大写字母\n\n　　和小写字母。例如：\n\n　　PRE_INCLUDE_REGEXESPRE_EXCLUDE_REGEXESPOST_INCLUDE_REGEXESPOST_EXCLUDE_REGEXES\n\n　　file(GET_RUNTIME_DEPENDENCIES\n\n# ...\n\n　　PRE_INCLUDE_REGEXES \"^[Mm][Yy][Ll][Ii][Bb][Rr][Aa][Rr][Yy]\\\\.[Dd][Ll][Ll]$\"\n\n　　)\n\n　　将 DLL 名称转换为小写允许正则表达式仅匹配 小写名称，从而简化正则表达\n\n　　式。例如：\n\n　　file(GET_RUNTIME_DEPENDENCIES\n\n# ...\n\n　　PRE_INCLUDE_REGEXES \"^mylibrary\\\\.dll$\"\n\n　　)\n\n　　无论大小写如何，此正则表达式都将匹配， 在磁盘上或相关文件中。（例如，它\n\n　　将匹配 、 和 。）mylibrary.dllmylibrary.dllMyLibrary.dllMYLIBRARY.DLL\n\n　　在 3.27 版更改： 转换为小写仅适用于匹配筛选器的情况。 筛选后报告的结果 -\n\n　　保留每个 DLL 名称原样 在磁盘上找到（如果已解析），否则由 依赖二进制文\n\n　　件。\n\n　　在 CMake 3.27 之前，结果使用小写 DLL 报告。 文件名，但目录部分保留其大\n\n　　小写。\n\n2. (尚未实施）如果依赖文件是 Windows 应用商店应用， 并且依赖项在应用程序\n\n　　的包中作为依赖项列出 清单中，依赖项将解析为该文件。\n\n3. 否则，如果库与依赖 文件，则依赖项将解析为该文件。\n4. 否则，如果库存在于操作系统的目录或目录中，则按该顺序， 依赖项解析为该文\n\n　　件。system32Windows\n\n5. 否则，如果库按列出的顺序存在于 指定的目录之一中，则解析依赖关系 到该文\n\n　　件。在这种情况下，不会发出警告，因为搜索 其他目录是Windows库解析的正\n\n　　常部分。DIRECTORIES\n\n6. 否则，依赖项将无法解析。\n\n　　在 Apple 平台上，库分辨率的工作方式如下：\n\n1. 如果依赖关系以 开头，并且参数正在解析中，并且 替换为可执行文件的目录 生\n\n　　成现有文件，依赖项将解析为该文件。\n\n　　@executable_path/EXECUTABLES@executable_path/\n\n2. 否则，如果依赖项以 开头，并且 是一个参数，替换为捆绑包可执行文件的目录\n\n　　会产生一个现有文件， 依赖项解析为该文件。\n\n　　@executable_path/BUNDLE_EXECUTABLE@executable_path/\n\n3. 否则，如果依赖项以 开头，并替换为依赖文件的目录，则会产生 现有文件，则\n\n　　依赖项解析为该文件。@loader_path/@loader_path/\n\n4. 否则，如果依赖项以 开头，并替换为依赖文件的条目之一 生成现有文件，依赖\n\n　　项将解析为该文件。 请注意，以这些项开头或同时将这些项替换为相应 路径。\n\n　　@rpath/@rpath/RPATHRPATH@executable_path/@loader_path/\n\n5. 否则，如果依赖项是存在的绝对文件， 依赖项将解析为该文件。\n6. 否则，依赖项将无法解析。\n\n　　此函数接受多个变量，这些变量确定用于哪个工具 依赖关系解析：\n\n　　CMAKE_GET_RUNTIME_DEPENDENCIES_PLATFORM¶\n\n　　确定构建文件的操作系统和可执行格式 为。这可能是以下几个值之一：\n\n　　linux+elf\n\n　　windows+pe\n\n　　macos+macho\n\n　　如果未指定此变量，则由系统自动确定 内省。\n\n　　CMAKE_GET_RUNTIME_DEPENDENCIES_TOOL¶\n\n　　确定用于依赖项解析的工具。它可能是其中之一 多个值，具体取决于 的值：\n\n　　CMAKE_GET_RUNTIME_DEPENDENCIES_PLATFORM CMAKE_GET_RUNTIME_DEPENDENCIES_TOOL\n\n　　linux+elf objdump\n\n　　windows+pe objdump或dumpbin\n\n　　macos+macho otool\n\n　　如果未指定此变量，则由系统自动确定 内省。\n\n　　CMAKE_GET_RUNTIME_DEPENDENCIES_COMMAND¶\n\n　　确定用于依赖项解析的工具的路径。这是 、 或 的实际路径。objdumpdumpbinotool\n\n　　如果未指定此变量，则由 if set 的值确定，否则由系统自检确定。CMAKE_OBJDUMP\n\n　　版本 3.18 中的新功能： 如果已设置，请使用。CMAKE_OBJDUMP\n\n　　写作¶\n\n　　文件（写<文件名><内容>...）¶\n\n　　文件（追加<文件名> <内容>...）¶\n\n　　写入名为 的文件中。如果文件有 不存在，它将被创建。如果文件已存在，mode 将覆盖\n\n　　它，模式将附加到末尾。 路径中指定的任何目录都不是 将创建存在。<content>\n\n<filename>WRITEAPPEND<filename>\n\n　　如果文件是生成输入，请使用命令 以仅在文件内容更改时更新文件。\n\n　　文件（触摸 [<文件>...]）¶\n\n　　文件（TOUCH_NOCREATE [<文件>...]）¶\n\n　　版本 3.12 中的新功能。\n\n　　创建一个没有内容的文件（如果尚不存在）。如果文件已经 存在，其访问和/或修改将更新\n\n　　到 执行函数调用。\n\n　　用于触摸文件（如果存在），但不创建文件。 如果文件不存在，它将被静默忽略。\n\n　　TOUCH_NOCREATE\n\n　　使用 和 ，现有文件的内容 不会被修改。TOUCHTOUCH_NOCREATE\n\n　　文件（生成 [...]）¶\n\n　　为当前 支持的每个构建配置生成输出文件。从输入内容进行评估以生成输出内容。\n\n　　file(GENERATE OUTPUT <output-file>\n\n<INPUT <input-file>|CONTENT <content>>\n\n　　[CONDITION <expression>] [TARGET <target>]\n\n　　[NO_SOURCE_PERMISSIONS | USE_SOURCE_PERMISSIONS |\n\n　　FILE_PERMISSIONS <permissions>...]\n\n　　[NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])\n\n　　选项包括：\n\n　　CONDITION <condition>\n\n　　仅在以下情况下生成特定配置的输出文件 条件为真。条件必须是在计算生成器表达\n\n　　式之后或之后。01\n\n　　CONTENT <content>\n\n　　使用明确给出的内容作为输入。\n\n　　INPUT <input-file>\n\n　　使用给定文件中的内容作为输入。\n\n　　在 3.10 版更改： 相对于 的值处理相对路径。请参阅策略 。\n\n　　OUTPUT <output-file>\n\n　　指定要生成的输出文件名。使用生成器表达式 例如指定特定于配置的 输出文件名。\n\n　　多个配置可能会生成相同的输出 仅当生成的内容相同时才文件。否则，必须计算为\n\n　　每个配置的唯一名称。<output-file>\n\n　　在 3.10 版更改： 处理相对路径（在计算生成器表达式之后） 关于 的值。 请参阅策\n\n　　略 。\n\n　　TARGET <target>\n\n　　版本 3.19 中的新功能。\n\n　　指定在计算生成器表达式时要使用的目标 需要一个评估目标（例如，）。\n\n　　NO_SOURCE_PERMISSIONS\n\n　　版本 3.20 中的新功能。\n\n　　生成的文件权限默认为标准 644 值 （-rw-r--r--）。\n\n　　USE_SOURCE_PERMISSIONS\n\n　　版本 3.20 中的新功能。\n\n　　将文件的文件权限转移到生成的 文件。这已经是默认行为，如果三个都不是 给出与\n\n　　权限相关的关键字 （， 或 ）。关键字主要用作制作方式 预期行为在呼叫站点更清\n\n　　晰。这是一个错误 指定此选项时不带 。\n\n　　INPUTNO_SOURCE_PERMISSIONSUSE_SOURCE_PERMISSIONSFILE_PERMISSIONSUSE_SOURC\n\n　　E_PERMISSIONSINPUT\n\n　　FILE_PERMISSIONS <permissions>...\n\n　　版本 3.20 中的新功能。\n\n　　对生成的文件使用指定的权限。\n\n　　NEWLINE_STYLE <style>\n\n　　版本 3.20 中的新功能。\n\n　　为生成的文件指定换行符样式。为换行符指定 或指定 、 或换行符。\n\n　　UNIXLF\\nDOSWIN32CRLF\\r\\n\n\n　　必须给出一个或选项。一个特定文件最多只能由一次调用来命名。 生成的文件被修改，其\n\n　　时间戳在后续的cmake上更新 仅当其内容发生更改时才运行。\n\n　　CONTENTINPUTOUTPUTfile(GENERATE)\n\n　　另请注意，在 生成阶段。命令返回时输出文件尚未写入，只有在处理完所有 的项目文件。\n\n　　file(GENERATE)file(GENERATE)CMakeLists.txt\n\n　　文件（配置输出 <输出文件>内容<内容> [ESCAPE_QUOTES] [@ONLY]\n\n　　[NEWLINE_STYLE [UNIX|DOS|WIN32|低频|CRLF] ]）¶\n\n　　版本 3.18 中的新功能。\n\n　　使用由和替换给出的输入生成输出文件 引用或包含在其中的变量值。这 替换规则的行为与\n\n　　命令相同。 为了匹配 的行为，生成器表达式 不支持 和 。CONTENT@VAR@${VAR}OUTPUTCONTENT\n\n　　参数是：\n\n　　OUTPUT <output-file>\n\n　　指定要生成的输出文件名。相对路径的处理方式为 尊重 的值。 不支持生成器表达\n\n　　式。<output-file>\n\n　　CONTENT <content>\n\n　　使用明确给出的内容作为输入。 不支持生成器表达式。<content>\n\n　　ESCAPE_QUOTES\n\n　　用反斜杠（C 样式）转义任何替换的引号。\n\n　　@ONLY\n\n　　将变量替换限制为表单 的引用。 这对于配置使用语法的脚本非常有用。\n\n　　@VAR@${VAR}\n\n　　NEWLINE_STYLE <style>\n\n　　指定输出文件的换行符样式。为换行符指定 或指定 、 或换行符。\n\n　　UNIXLF\\nDOSWIN32CRLF\\r\\n\n\n　　文件系统¶\n\n　　file（GLOB <可变> [LIST_DIRECTORIES true|错误] [相对 <路径>]\n\n　　[CONFIGURE_DEPENDS] [<通配表达式>...]）¶\n\n　　file（GLOB_RECURSE <可变> [FOLLOW_SYMLINKS] [LIST_DIRECTORIES true|错误]\n\n　　[相对 <路径>] [CONFIGURE_DEPENDS] [<通配表达式>...]）¶\n\n　　生成与 和 匹配的文件列表 将其存储到 .通配表达式类似于 正则表达式，但要简单得多。如\n\n　　果标志是 指定，结果将作为给定的相对路径返回 路径。<globbing-expressions>\n\n<variable>RELATIVE\n\n　　在 3.6 版更改： 结果将按字典顺序排序。\n\n　　在 Windows 和 macOS 上，通配不区分大小写，即使底层 文件系统区分大小写（文件名\n\n　　和通配表达式都是 在匹配之前转换为小写）。在其他平台上，通配是 区分大小写。\n\n　　版本 3.3 中的新功能： 默认情况下列出目录。目录中省略了目录 结果如果设置为 false。\n\n　　GLOBLIST_DIRECTORIES\n\n　　版本 3.12 中的新功能： 如果指定了该标志，CMake 将添加逻辑 到主构建系统检查目标，\n\n　　以在构建时重新运行标记的命令。如果任何输出发生变化，CMake 将重新生成 构建系统。\n\n　　CONFIGURE_DEPENDSGLOB\n\n　　注意\n\n　　我们不建议使用 GLOB 从以下位置收集源文件列表 您的源树。如果没有 CMakeLists.txt则\n\n　　当源 添加或删除，然后生成的构建系统无法知道何时 要求 CMake 再生。 该标志可能无法\n\n　　在所有生成器上可靠地工作，或者 如果将来添加了无法支持它的新生成器，则项目 使用它\n\n　　会被卡住。即使工作可靠，也有 仍然是每次重建时执行检查的成本。\n\n　　CONFIGURE_DEPENDSCONFIGURE_DEPENDS\n\n　　通配表达式的示例包括：\n\n*.cxx 匹配所有具有扩展名的文件cxx\n\n*.vt? 匹配所有扩展名 ， ...，vtavtz\n\n　　f[3-5].txt 匹配文件 ， ，f3.txtf4.txtf5.txt\n\n　　该模式将遍历 匹配目录并匹配文件。作为符号链接的子目录 仅当给定或策略未设置为 时，\n\n　　才会遍历。GLOB_RECURSEFOLLOW_SYMLINKSNEW\n\n　　版本 3.3 中的新功能： 默认情况下，从结果列表中省略目录。设置为 true 会将目录添加到\n\n　　结果列表。 如果给定或策略未设置为 ，则将符号链接视为目录。\n\n　　GLOB_RECURSELIST_DIRECTORIESFOLLOW_SYMLINKSNEWLIST_DIRECTORIES\n\n　　递归通配的示例包括：\n\n　　/dir/*.py 匹配 和 子目录中的所有 Python 文件/dir\n\n　　文件（MAKE_DIRECTORY [<目录>...]）¶\n\n　　根据需要创建给定的目录及其父目录。\n\n　　文件（删除 [<文件>...]）¶\n\n　　文件（REMOVE_RECURSE [<文件>...]）¶\n\n　　删除给定的文件。该模式将删除给定的 文件和目录，包括非空目录。不发出错误 如果给定\n\n　　文件不存在。相对输入路径的计算方式为 尊重当前源目录。REMOVE_RECURSE\n\n　　在 3.15 版更改： 空输入路径将被忽略，并显示警告。CMake 的早期版本 将空字符串解释\n\n　　为相对于当前路径的相对路径 目录并删除了其内容。\n\n　　文件（重命名 <旧名称> <新名称> [结果<结果>] [NO_REPLACE]）¶\n\n　　将文件系统中的文件或目录从 移动到 ，以原子方式替换目标。<oldname><newname>\n\n　　选项包括：\n\n　　RESULT <result>\n\n　　版本 3.21 中的新功能。\n\n　　将变量设置为成功时或错误消息 否则。如果未指定且操作失败， 发出错误。\n\n<result>0RESULT\n\n　　NO_REPLACE\n\n　　版本 3.21 中的新功能。\n\n　　如果路径已存在，请不要替换它。 如果使用，则结果变量将为 设置为 。否则，将发\n\n　　出错误。<newname>RESULT <result>NO_REPLACE\n\n　　file（COPY_FILE <旧名称> <新名称> [结果 <结果>] [ONLY_IF_DIFFERENT]\n\n　　[INPUT_MAY_BE_RECENT]）¶\n\n　　版本 3.21 中的新功能。\n\n　　将文件从 复制到 。目录不是 支持。符号链接被忽略，并且 的内容被读取和 写入 作为新文\n\n　　件。<oldname><newname><oldfile><newname>\n\n　　选项包括：\n\n　　RESULT <result>\n\n　　将变量设置为成功时或错误消息 否则。如果未指定且操作失败， 发出错误。\n\n<result>0RESULT\n\n　　ONLY_IF_DIFFERENT\n\n　　如果路径已存在，则不要替换它，如果文件的 内容已经与 相同（这样可以避免更新\n\n　　的时间戳）。<newname><oldname><newname>\n\n　　INPUT_MAY_BE_RECENT\n\n　　版本 3.26 中的新功能。\n\n　　告诉 CMake 输入文件可能是最近创建的。这是 仅在 Windows 上有意义，其中文\n\n　　件可能在短时间内无法访问 创建后的时间。使用此选项，如果权限被拒绝， CMake\n\n　　将重试读取输入几次。\n\n　　此子命令与选项有一些相似之处。一个重要的区别是创建了对源文件的依赖关系， 因此，\n\n　　如果CMake发生变化，它将重新运行。子命令不会创建此类依赖项。\n\n　　COPYONLYfile(COPY_FILE)\n\n　　另请参阅下面的子命令，它提供 进一步的文件复制功能。\n\n　　文件（复制 [...]）¶\n\n　　文件（安装 [...]）¶\n\n　　签名将文件、目录和符号链接复制到 目标文件夹。相对输入路径的评估 到当前源目录，相\n\n　　对目标是 相对于当前构建目录进行评估。复制 保留输入文件时间戳，并优化文件（如果存\n\n　　在） 在具有相同时间戳的目标。复制可保留输入 权限，除非授予显式权限或权限（默认值\n\n　　为 ）。COPYNO_SOURCE_PERMISSIONSUSE_SOURCE_PERMISSIONS\n\n　　file(<COPY|INSTALL> <files>... DESTINATION <dir>\n\n　　[NO_SOURCE_PERMISSIONS | USE_SOURCE_PERMISSIONS]\n\n　　[FILE_PERMISSIONS <permissions>...]\n\n　　[DIRECTORY_PERMISSIONS <permissions>...]\n\n　　[FOLLOW_SYMLINK_CHAIN]\n\n　　[FILES_MATCHING]\n\n　　[[PATTERN <pattern> | REGEX <regex>]\n\n　　[EXCLUDE] [PERMISSIONS <permissions>...]] [...])\n\n　　注意\n\n　　对于简单的文件复制操作，上面的子命令可能更易于使用。\n\n　　版本 3.15 中的新功能： 如果指定，将递归解析 在找到真实文件之前给定路径中的符号链\n\n　　接，并安装 目标中遇到的每个符号链接的相应符号链接。 对于安装的每个符号链接，分辨\n\n　　率将去除 目录，只留下文件名，这意味着新的符号链接指向 到与符号链接位于同一目录中\n\n　　的文件。此功能在 一些Unix系统，其中库作为符号链接链安装 带有版本号，不太具体的版\n\n　　本指向更具体的版本 版本。 将安装所有这些符号链接和 库本身进入目标目录。例如，如果\n\n　　您有 以下目录结构：FOLLOW_SYMLINK_CHAINCOPYFOLLOW_SYMLINK_CHAIN\n\n　　/opt/foo/lib/libfoo.so.1.2.3\n\n　　/opt/foo/lib/libfoo.so.1.2 -> libfoo.so.1.2.3\n\n　　/opt/foo/lib/libfoo.so.1 -> libfoo.so.1.2\n\n　　/opt/foo/lib/libfoo.so -> libfoo.so.1\n\n　　而你确实：\n\n　　file(COPY /opt/foo/lib/libfoo.so DESTINATION lib FOLLOW_SYMLINK_CHAIN)\n\n　　这会将所有符号链接及其自身安装到 .libfoo.so.1.2.3lib\n\n　　有关文档，请参阅命令 权限、、 和选项。复制目录可保留结构 ，即使选项用于选择 文\n\n　　件。FILES_MATCHINGPATTERNREGEXEXCLUDE\n\n　　签名与 ： 它打印 状态消息，并且是默认值。安装 命令生成的脚本使用此签名 （有一些未\n\n　　记录的内部使用选项）。INSTALLCOPYNO_SOURCE_PERMISSIONS\n\n　　在 3.22 版更改： 环境变量可以覆盖 的默认复制行为 。\n\n　　文件（大小<文件名><可变>）¶\n\n　　版本 3.14 中的新功能。\n\n　　确定 的文件大小并将结果放入变量中。要求该路径为有效路径 指向文件，并且可读。\n\n<filename><variable><filename>\n\n　　file（READ_SYMLINK <链接名> <变量>）¶\n\n　　版本 3.14 中的新功能。\n\n　　查询符号链接并存储其指向的路径 在结果中.如果不存在 或者不是符号链接，CMake 会发\n\n　　出致命错误。<linkname><variable><linkname>\n\n　　请注意，此命令返回原始符号链接路径，并且不会解析 相对路径。下面是如何确保 获得绝\n\n　　对路径：\n\n　　set(linkname \"/path/to/foo.sym\")\n\n　　file(READ_SYMLINK \"${linkname}\" result)\n\n　　if(NOT IS_ABSOLUTE \"${result}\")\n\n　　get_filename_component(dir \"${linkname}\" DIRECTORY)\n\n　　set(result \"${dir}/${result}\")\n\n　　endif()\n\n　　文件（CREATE_LINK <原始> <链接名称> [结果 <结果>] [COPY_ON_ERROR] [象征\n\n　　性]）¶\n\n　　版本 3.14 中的新功能。\n\n　　创建指向 的链接。 默认情况下，它将是一个硬链接，但提供选项 改为生成符号链接。硬链\n\n　　接要求存在，并且是一个文件，而不是一个目录。如果已经存在， 它将被覆盖。<linkname>\n\n<original>SYMBOLICoriginal<linkname>\n\n　　该变量（如果指定）接收 操作。它设置为成功时，否则会显示错误消息。 如果未指定并且\n\n　　操作失败，则致命错误为 排放。<result>0RESULT\n\n　　指定允许复制文件作为回退，如果 创建链接失败。它可用于处理诸如位于不同驱动器或挂\n\n　　载点上的情况， 这将使他们无法支持硬链接。COPY_ON_ERROR<original><linkname>\n\n　　文件（CHMOD <文件>... <目录>... [权限<权限>...] [FILE_PERMISSIONS<权限>...]\n\n　　[DIRECTORY_PERMISSIONS<权限>...]）¶\n\n　　版本 3.19 中的新功能。\n\n　　设置 和 的权限。有效权限为 、、、<files>...\n\n<directories>...OWNER_READOWNER_WRITEOWNER_EXECUTEGROUP_READGROUP_WRITEGROUP_EXECUTEWORLD_R\n\n　　EADWORLD_WRITEWORLD_EXECUTESETUIDSETGID\n\n　　关键字的有效组合包括：\n\n　　PERMISSIONS\n\n　　所有项目均已更改。\n\n　　FILE_PERMISSIONS\n\n　　仅更改文件。\n\n　　DIRECTORY_PERMISSIONS\n\n　　仅更改目录。\n\n　　PERMISSIONS和FILE_PERMISSIONS\n\n　　FILE_PERMISSIONS文件的替代。PERMISSIONS\n\n　　PERMISSIONS和DIRECTORY_PERMISSIONS\n\n　　DIRECTORY_PERMISSIONS目录的覆盖。PERMISSIONS\n\n　　FILE_PERMISSIONS和DIRECTORY_PERMISSIONS\n\n　　用于文件和 目录。FILE_PERMISSIONSDIRECTORY_PERMISSIONS\n\n　　文件（CHMOD_RECURSE <文件>... <目录>... [权限<权限>...] [FILE_PERMISSIONS<权\n\n　　限>...] [DIRECTORY_PERMISSIONS<权限>...]）¶\n\n　　版本 3.19 中的新功能。\n\n　　与 相同，但更改文件和目录的权限 以递归方式存在。<directories>...\n\n　　路径转换¶\n\n　　file（REAL_PATH <路径> <输出变量> [BASE_DIRECTORY <目录>] [EXPAND_TILDE]）\n\n　　¶\n\n　　版本 3.19 中的新功能。\n\n　　使用符号链接计算现有文件或目录的绝对路径 解决。选项包括：\n\n　　BASE_DIRECTORY <dir>\n\n　　如果提供的路径是相对路径，则相对计算 到给定的基目录 。如果未提供基目录， 默\n\n　　认基目录将为 。<path><dir>\n\n　　EXPAND_TILDE\n\n　　版本 3.21 中的新功能。\n\n　　如果 是 或 以 开头，则 被替换 按用户的主目录。获取主目录的路径 从环境变量。在\n\n　　Windows 上，环境 使用变量，回退到环境变量 如果未定义。在所有其他平台上，\n\n　　仅使用。<path>~~/~USERPROFILEHOMEUSERPROFILEHOME\n\n　　在 3.28 版更改： 所有符号链接在折叠组件之前解析。 请参阅策略 。../\n\n　　file（RELATIVE_PATH <可变> <目录> <文件>）¶\n\n　　计算从 a 到 a 和 的相对路径 将其存储在 .<directory><file><variable>\n\n　　文件（TO_CMAKE_PATH “<路径>” <变量>）¶\n\n　　文件（TO_NATIVE_PATH “<路径>” <可变>）¶\n\n　　该模式将原生转换为 cmake 样式 带正斜杠 （） 的路径。输入可以是单个路径或 系统搜索\n\n　　路径，如 。搜索路径将被转换 到由字符分隔的 cmake 样式列表。\n\n　　TO_CMAKE_PATH<path>/$ENV{PATH};\n\n　　该模式将 cmake 样式转换为本机样式 带有特定于平台的斜杠的路径（在 Windows 主机\n\n　　上和其他地方）。TO_NATIVE_PATH<path>\\/\n\n　　始终在 两边使用双引号以确保它被处理 作为此命令的单个参数。<path>\n\n　　转移¶\n\n　　文件（下载 <网址> [<文件>] [<选项>...]）¶\n\n　　文件（上传<文件> <网址> [<选项>...]）¶\n\n　　子命令将给定的下载到本地 .该模式将本地上传到给定的 .DOWNLOAD<url><file>UPLOAD<file>\n\n<url>\n\n　　版本 3.19 中的新功能： 如果未为 指定 ，则文件不是 保存。如果您想知道是否可以下载文\n\n　　件，这会很有用 （例如，检查它是否存在）而不实际将其保存在任何地方。\n\n<file>file(DOWNLOAD)\n\n　　两者的选项包括：DOWNLOADUPLOAD\n\n　　INACTIVITY_TIMEOUT <seconds>\n\n　　在一段时间不活动后终止操作。\n\n　　LOG <variable>\n\n　　在变量中存储人类可读的操作日志。\n\n　　SHOW_PROGRESS\n\n　　将进度信息打印为状态消息，直到操作 完成。\n\n　　STATUS <variable>\n\n　　将操作的结果状态存储在变量中。 状态是长度为 2 的单独列表。 第一个元素是操作\n\n　　的数字返回值， 第二个元素是错误的字符串值。 数值错误表示操作中没有错误。;0\n\n　　TIMEOUT <seconds>\n\n　　在给定的总时间过后终止操作。\n\n　　USERPWD <username>:<password>\n\n　　版本 3.7 中的新功能。\n\n　　设置操作用户名和密码。\n\n　　HTTPHEADER <HTTP-header>\n\n　　版本 3.7 中的新功能。\n\n　　和操作的 HTTP 标头。 可以重复多个选项：DOWNLOADUPLOADHTTPHEADER\n\n　　file(DOWNLOAD <url>\n\n　　HTTPHEADER \"Authorization: Bearer <auth-token>\"\n\n　　HTTPHEADER \"UserAgent: Mozilla/5.0\")\n\n　　NETRC <level>\n\n　　版本 3.11 中的新功能。\n\n　　指定是否将 .netrc 文件用于操作。如果这个 选项未指定，将改用变量的值。\n\n　　有效级别为：\n\n　　IGNORED\n\n　　.netrc 文件将被忽略。 这是默认值。\n\n　　OPTIONAL\n\n　　.netrc 文件是可选的，URL 中的信息是首选。 将扫描文件以查找哪些信息不\n\n　　是 在 URL 中指定。\n\n　　REQUIRED\n\n　　.netrc 文件是必需的，URL 中的信息将被忽略。\n\n　　NETRC_FILE <file>\n\n　　版本 3.11 中的新功能。\n\n　　指定主目录中的替代 .netrc 文件， 如果级别为 或 。如果此选项 未指定，则变量的\n\n　　值 将改为使用。NETRCOPTIONALREQUIRED\n\n　　TLS_VERIFY <ON|OFF>\n\n　　指定是否验证 URL 的服务器证书。 默认值为不验证。如果未指定此选项，则 将改用\n\n　　变量的值。https://\n\n　　版本 3.18 中的新功能： 添加了对 的支持。file(UPLOAD)\n\n　　TLS_CAINFO <file>\n\n　　为 URL 指定自定义证书颁发机构文件。 如果未指定此选项，则将改用变量的值。\n\n　　https://\n\n　　版本 3.18 中的新功能： 添加了对 的支持。file(UPLOAD)\n\n　　对于 URL，CMake 必须使用 OpenSSL 支持构建。 默认情况下不检查证书。设置为 检查\n\n　　证书。https://TLS/SSLTLS_VERIFYON\n\n　　其他选项包括：DOWNLOAD\n\n　　EXPECTED_HASH <algorithm>=<value>\n\n　　验证下载的内容哈希是否与预期值匹配，其中 是 支持的算法之一。 如果文件已存在\n\n　　且与哈希匹配，则跳过下载。 如果文件已存在且与哈希不匹配，则该文件是 再次下\n\n　　载。如果下载后文件与哈希不匹配，则 操作失败并显示错误。如果未指定此选项，\n\n　　则指定此选项是错误的。<algorithm>DOWNLOAD<file>\n\n　　EXPECTED_MD5 <value>\n\n　　的历史简写。这是一个错误 如果未指定 .EXPECTED_HASH MD5=\n\n<value>DOWNLOAD<file>\n\n　　RANGE_START <value>\n\n　　版本 3.24 中的新功能。\n\n　　文件范围开头的偏移量（以字节为单位）。可以省略到 下载到指定的 .RANGE_END\n\n　　RANGE_END <value>\n\n　　版本 3.24 中的新功能。\n\n　　文件范围末尾的偏移量（以字节为单位）。可以省略到 下载从指定到结尾的所有内\n\n　　容 文件。RANGE_START\n\n　　锁定¶\n\n　　文件（锁定 <路径> [目录] [发布] [保护<功能|文件|进程>] [RESULT_VARIABLE<可变>]\n\n　　[超时 <秒>]） ¶\n\n　　版本 3.2 中的新功能。\n\n　　锁定指定的文件，如果不存在选项，并且 否则。该文件将被锁定为范围 由选项定义（默认\n\n　　值为 ）。该选项可用于显式解锁文件。如果未指定该选项，CMake 将等待锁定成功 或直\n\n　　到发生致命错误。如果设置为 ，则锁定将 尝试一次，结果将立即报告。如果不是，CMake\n\n　　将尝试在指定的时间段内锁定文件。 值。任何错误都将被解释为致命的，如果 别无选择。\n\n　　否则，结果将被存储 在 和 将成功或错误消息 失败。\n\n<path>DIRECTORY<path>/cmake.lockGUARDPROCESSRELEASETIMEOUTTIMEOUT0TIMEOUT0TIMEOUT\n\n<seconds>RESULT_VARIABLE<variable>0\n\n　　请注意，锁定是建议性的;不能保证其他进程会 尊重此锁，即锁同步两个或多个 CMake 实\n\n　　例共享 一些可修改的资源。类似的逻辑适用于该选项; 锁定父目录不会阻止其他命令 锁定\n\n　　任何子目录或文件。DIRECTORYLOCK\n\n　　不允许尝试两次锁定同一文件。任何中间体 目录和文件本身（如果不存在）将被创建。和\n\n　　选项在操作中被忽略。GUARDTIMEOUTRELEASE\n\n　　归档¶\n\n　　文件（ARCHIVE_CREATE 输出 <存档> 路径<路径>... [格式 <格式>] [压缩<压缩>\n\n　　[COMPRESSION_LEVEL<压缩 级别>]] [MTIME <mtime>] [详细]）¶\n\n　　版本 3.18 中的新功能。\n\n　　使用文件和目录创建指定的文件 在 中列出。请注意，必须列出实际文件或 目录;不支持通\n\n　　配符。<archive><paths><paths>\n\n　　使用该选项指定存档格式。支持的值 对于 是 、 、 、 和 。如果未给出，则默认格式为 。\n\n　　FORMAT<format>7zipgnutarpaxpaxrrawzipFORMATpaxr\n\n　　某些存档格式允许指定压缩类型。 和存档格式已经意味着特定类型的 压缩。其他格式默认\n\n　　不使用压缩，但可以是 指示使用选项执行此操作。的有效值为 、、 和 。\n\n　　7zipzipCOMPRESSION<compression>NoneBZip2GZipXZZstd\n\n　　版本 3.19 中的新功能： 可以使用该选项指定压缩级别。应介于 0-9 之间，其中 默认值为\n\n　　0。给出选项时必须存在。COMPRESSION_LEVEL<compression-level>COMPRESSIONCOMPRESSION_LEVEL\n\n　　版本 3.26 中的新功能： 的算法可以设置 在 0-19 之间。<compression-level>Zstd\n\n　　注意\n\n　　设置为 时，将仅使用 由 指定的压缩类型。FORMATrawCOMPRESSION\n\n　　该选项为存档操作启用详细输出。VERBOSE\n\n　　要指定压缩包条目中记录的修改时间，请使用 选项。MTIME\n\n　　文件（ARCHIVE_EXTRACT 输入 <存档> [目标 <目录>] [模式<模式>... ] [LIST_ONLY]\n\n　　[详细] [触摸]） ¶\n\n　　版本 3.18 中的新功能。\n\n　　提取或列出指定 .<archive>\n\n　　将存档内容提取到的目录可以 使用该选项指定。如果目录没有 存在，它将被创建。如果未\n\n　　给出，则当前 将使用二进制目录。DESTINATIONDESTINATION\n\n　　如果需要，您可以选择要列出或提取的文件和目录 从存档中使用指定的 .通配符是 支持。\n\n　　如果未给出该选项，则整个存档将 被列出或提取。<patterns>PATTERNS\n\n　　LIST_ONLY将列出存档中的文件，而不是提取它们。\n\n　　版本 3.24 中的新功能： 该选项为提取的文件提供当前本地文件 时间戳，而不是从存档中\n\n　　提取文件时间戳。TOUCH\n\n　　使用 ，该命令将生成详细输出。","edit_time_ms":1698023268177,"snapshots":[{"id":"01hdc3j16rkncmvy1hakjxdwze","item_id":"01hdbw4fmj8d5fjtt7ax3514fh","add_time_ms":1697992213721,"hash":"16a93d52fd132f9956f7e3f1cb181f32","length":20161,"char_count_char_with_spaces":18990,"char_count_char_without_spaces":16959,"char_count_word":9297},{"id":"01hdd642ba435b4xmv52ppy6x3","item_id":"01hdbw4fmj8d5fjtt7ax3514fh","add_time_ms":1698028456298,"hash":"33139249cc5aef5b522675c0e55fa1ea","length":20260,"char_count_char_with_spaces":19086,"char_count_char_without_spaces":17031,"char_count_word":9325}]}