{"id":"01hdbcfvynjc8vhtmqhsfr5pzs","add_time_ms":1697968025557,"icon":"book","type":"doc","title":"add_library","_id":"92","char_count":{"word":908,"char_without_spaces":3251,"char_with_spaces":3585,"char_all":3747},"content":"# cmake : add_library详解\n\n　　add_library是写cmake必备的一个函数，但一直没仔细研究过，今天把它折解下。主要参考\n\n　　cmake官方文档\n\n## normal library\n\n　　add_library(<name> [STATIC | SHARED | MODULE]\n\n　　[EXCLUDE_FROM_ALL]\n\n　　[source1] [source2 ...])\n\n　　添加名为name的库，库的源文件可指定，也可用target_sources()后续指定。\n\n　　库的类型是STATIC(静态库)/SHARED(动态库)/MODULE(模块库)之一。\n\n　　name属性必须全局唯一\n\n　　生成的library名会根据STATIC或SHARED成为name.a或name.lib\n\n　　这里的STATIC和SHARED可不设置，通过全局的BUILD_SHARED_LIBS的FALSE或TRUE来指定\n\n　　windows下，如果dll没有export任何信息，则不能使用SHARED，要标识为MODULE\n\n　　添加的库会被输出到以下几个目录\n\n　　ARCHIVE_OUTPUT_DIRECTORY, LIBRARY_OUTPUT_DIRECTORY和 RUNTIME_OUTPUT_DIRECTORY，详见cmake 常用设定及函数\n\n　　设置EXCLUDE_FROM_ALL，可使这个library排除在all之外，即必须明确点击生成才会生成\n\n## imported library\n\n　　add_library(<name> <SHARED|STATIC|MODULE|OBJECT|UNKNOWN> IMPORTED\n\n　　[GLOBAL])\n\n　　这种用法直接导入已经生成的库，cmake不会给这类library添加编译规则。\n\n　　这种用法的关键在于添加变量IMPORTED。\n\n　　另外，GLOBAL可用于设置这个library为全局可见。\n\n　　常规和imported的library的属性不同：\n\n　　常规的library，其属性以INTERFACE_开头\n\n　　imported的library，其属性以IMPORTED_开头\n\n　　INTERFACE_和IMPORTED_开头的变量有哪些，参见interface libraries，还需再研究。\n\n　　imported的library最重要的几个属性是：\n\n　　IMPORTED_LOCATION:标明library在硬盘上的位置，可以用更具体的IMPORTED_LOCATION_<CONFIG>的标注，其中的<CONFIG>可以是DEBUG/RELEASE或其他\n\n　　IMPORTED_OBJECTS：标明对象library在硬盘上的位置，相应的有IMPORTED_OBJECTS_<CONFIG>来标识具体编译类型\n\n　　PUBLIC_HEADER：如果install这个library的话，这个值保存头文件的目录\n\n　　UNKNOWN类型，在不需要明确library类型时使用。\n\n## object library\n\n　　add_library(<name> OBJECT <src>...)\n\n　　库的类型固定为OBJECT，这种库编译了源文件，但不链接。实际中没用过，没有仔细研究。使用方法：\n\n　　add_library(... $<TARGET_OBJECTS:objlib> ...)\n\n　　add_executable(... $<TARGET_OBJECTS:objlib> ...)\n\n## alias library（别名库）\n\n　　为给定library添加一个别名，后续可使用<name>来替代<target>。\n\n　　add_library(<name> ALIAS <target>)\n\n　　使用有如下限制：\n\n<target>不能是ALIAS\n\n　　可用于判断target是否存在、链接。\n\n　　ALIAS的library不能修改属性，不能调用set_property(), set_target_properties()和target_link_libraries()等方法\n\n　　不能用于install()\n\n## interface library\n\n　　创建一个接口库，\n\n　　add_library(<name> INTERFACE [IMPORTED [GLOBAL]])\n\n　　这类库有属性，能install()，export和imported，但可能没有build过程。像纯头文件库或完全针对target的设计（这条参见interface libraries）\n\n　　所有INTERFACE _*属性从如下几个方法中设置\n\n　　set_property()、target_link_libraries(INTERFACE)、target_link_options(INTERFACE)、target_include_directories(INTERFACE)、target_compile_options(INTERFACE)、target_compile_definitions(INTERFACE)和target_sources(INTERFACE)。\n\n# 手工配置库\n\n　　参考 cmake引入外部库\n\n## 静态库\n\n　　add_library(baz STATIC IMPORTED)\n\n　　set_target_properties(baz PROPERTIES\n\n　　IMPORTED_LOCATION_RELEASE ${CMAKE_CURRENT_SOURCE_DIR}/libbaz.a\n\n　　IMPORTED_LOCATION_DEBUG ${CMAKE_CURRENT_SOURCE_DIR}/libbazd.a)\n\n　　静态库(添加依赖项)\n\n　　add_library(bar STATIC IMPORTED)\n\n　　set_target_properties(bar PROPERTIES\n\n　　IMPORTED_LOCATION_RELEASE ${CMAKE_CURRENT_SOURCE_DIR}/libbar.a\n\n　　IMPORTED_LOCATION_DEBUG ${CMAKE_CURRENT_SOURCE_DIR}/libbard.a\n\n　　IMPORTED_LINK_INTERFACE_LIBRARIES baz) # <-- dependency is here\n\n## 动态库\n\n  #### Windows平台下, 需要在顶级CMakeLists.txt文件中设置: CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS 为 1来到出dll符号.\n            if(MSVC)\n              set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS 1)\n              set(CMAKE_LIBRARY_OUTPUT_DIRECTORY /lib)\n            endif()\n  ####  否则会链接不成功.\n\n  ### 加上以下配置可以将库生成到可执行文件对应的目录,免去了后续手动复制到执行路径.\n    set_target_properties(${PROJECT_NAME}\n        PROPERTIES\n        LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/$<CONFIG>/lib\n        ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/$<CONFIG>/lib\n        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/$<CONFIG>/bin\n       \n        FOLDER \"External\"\n        )\n\n\n　　add_library(bar SHARED IMPORTED)\n\n　　set_property(TARGET bar PROPERTY IMPORTED_LOCATION c:/path/to/bar.dll)\n\n　　set_property(TARGET bar PROPERTY IMPORTED_IMPLIB c:/path/to/bar.lib) # 多了lib信息\n\n　　add_executable(myexe src1.c src2.c)\n\n　　target_link_libraries(myexe bar)\n\n　　当然，也可以直接引用库文件\n\n　　TARGET_LINK_LIBRARIES(skiaSampleCode\n\n　　debug skiaCored.lib\n\n　　optimized skiaCore.lib)","edit_time_ms":1698021267748,"snapshots":[{"id":"01hdbcqtbnp3xxp9jw0wjbb3gq","item_id":"01hdbcfvynjc8vhtmqhsfr5pzs","add_time_ms":1697968286069,"hash":"e56bf666d9ec46028fc7bee78a22ef97","length":2969,"char_count_char_with_spaces":2879,"char_count_char_without_spaces":2773,"char_count_word":806},{"id":"01hdbda4dta05eb7hewd5mzhvg","item_id":"01hdbcfvynjc8vhtmqhsfr5pzs","add_time_ms":1697968886202,"hash":"8e4e04ed9c62e6788d2da89cf823ff9c","length":3133,"char_count_char_with_spaces":2989,"char_count_char_without_spaces":2786,"char_count_word":813},{"id":"01hdbg5qhwwftw3kczxzeghv6t","item_id":"01hdbcfvynjc8vhtmqhsfr5pzs","add_time_ms":1697971887676,"hash":"35d975f3cf4e8182c33513baed70abea","length":3284,"char_count_char_with_spaces":3135,"char_count_char_without_spaces":2909,"char_count_word":837},{"id":"01hdbgr1zaz12nw588j1td5k4a","item_id":"01hdbcfvynjc8vhtmqhsfr5pzs","add_time_ms":1697972488170,"hash":"d66bb0662889fd48fc8edb63613992c3","length":3338,"char_count_char_with_spaces":3188,"char_count_char_without_spaces":2935,"char_count_word":855},{"id":"01hdcz87pnaca3n19aqjqs0bdv","item_id":"01hdbcfvynjc8vhtmqhsfr5pzs","add_time_ms":1698021252821,"hash":"9678e8e93207967a1a5eb2278f86d9d1","length":3737,"char_count_char_with_spaces":3575,"char_count_char_without_spaces":3241,"char_count_word":898},{"id":"01hdczthzdv3e7gxf6aweg4rcy","item_id":"01hdbcfvynjc8vhtmqhsfr5pzs","add_time_ms":1698021853165,"hash":"16db72b76738ae5fe1e43937a01cb2b8","length":3747,"char_count_char_with_spaces":3585,"char_count_char_without_spaces":3251,"char_count_word":908}]}