{"id":"01hdr7sfw2hjc09abpmk0162eq","add_time_ms":1698399305602,"icon":"book","type":"doc","title":"C++学习笔记","_id":"102","char_count":{"word":548,"char_without_spaces":1409,"char_with_spaces":1706,"char_all":1834},"content":"# 静态局部变量的懒汉单例（C++11线程安全）(推荐这种方式实现单例模式)\n头文件：\n\n///  内部静态变量的懒汉实现  //\n\nclass Single\n{\n\npublic:\n    // 获取单实例对象\n    static Single& GetInstance();\n\t\n\t// 打印实例地址\n    void Print();\n\nprivate:\n    // 禁止外部构造\n    Single();\n\n    // 禁止外部析构\n    ~Single();\n\n    // 禁止外部拷贝构造\n    Single(const Single &single) = delete;\n\n    // 禁止外部赋值操作\n    const Single &operator=(const Single &single) = delete;\n};\n\n源文件：\n\nSingle& Single::GetInstance()\n{\n    /**\n     * 局部静态特性的方式实现单实例。\n     * 静态局部变量只在当前函数内有效，其他函数无法访问。\n     * 静态局部变量只在第一次被调用的时候初始化，也存储在静态存储区，生命周期从第一次被初始化起至程序结束止。\n     */\n    static Single single;\n    return single;\n}\n\nvoid Single::Print()\n{\n    std::cout << \"我的实例内存地址是:\" << this << std::endl;\n}\n\nSingle::Single()\n{\n    std::cout << \"构造函数\" << std::endl;\n}\n\nSingle::~Single()\n{\n    std::cout << \"析构函数\" << std::endl;\n}\n\n在 C++11 中，静态局部变量这种方式天然是线程安全的，不存在线程安全的问题。\n\n\n\n\n\n\n# 饿汉式单例（线程安全）\n头文件：\n\n// 饿汉实现 /\n\nclass Singleton\n{\npublic:\n    // 获取单实例\n    static Singleton* GetInstance();\n\n    // 释放单实例，进程退出时调用\n    static void deleteInstance();\n    \n    // 打印实例地址\n    void Print();\n\nprivate:\n    // 将其构造和析构成为私有的, 禁止外部构造和析构\n    Singleton();\n    ~Singleton();\n\n    // 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值\n    Singleton(const Singleton &signal);\n    const Singleton &operator=(const Singleton &signal);\n\nprivate:\n    // 唯一单实例对象指针\n    static Singleton *g_pSingleton;\n};\n\n源文件：\n\n// 代码一运行就初始化创建实例 ，本身就线程安全\nSingleton* Singleton::g_pSingleton = new (std::nothrow) Singleton();\n\nSingleton* Singleton::GetInstance()\n{\n    return g_pSingleton;\n}\n\nvoid Singleton::deleteInstance()\n{\n    if (g_pSingleton)\n    {\n        delete g_pSingleton;\n        g_pSingleton = nullptr;\n    }\n}\n\nvoid Singleton::Print()\n{\n    std::cout << \"我的实例内存地址是:\" << this << std::endl;\n}\n\nSingleton::Singleton()\n{\n    std::cout << \"构造函数\" << std::endl;\n}\n\nSingleton::~Singleton()\n{\n    std::cout << \"析构函数\" << std::endl;\n}\n","edit_time_ms":1698399623219,"snapshots":[{"id":"01hdr80prsz4e65fmg635bkhnk","item_id":"01hdr7sfw2hjc09abpmk0162eq","add_time_ms":1698399542041,"hash":"e94e0dd718ec2ec962937679a13e95d2","length":1817,"char_count_char_with_spaces":1692,"char_count_char_without_spaces":1395,"char_count_word":534},{"id":"01hdr8k167ys46ys80t3m1ts20","item_id":"01hdr7sfw2hjc09abpmk0162eq","add_time_ms":1698400142535,"hash":"7ca96d434a7bc323a14af06795422b34","length":1834,"char_count_char_with_spaces":1706,"char_count_char_without_spaces":1409,"char_count_word":548}]}