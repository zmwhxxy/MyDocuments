{"id":"01hdbw3zrbd2d0gtshpekg217d","add_time_ms":1697984413451,"icon":"book","type":"doc","title":"object library","_id":"93","char_count":{"word":469,"char_without_spaces":798,"char_with_spaces":859,"char_all":881},"content":"# CMake 对象库的优点\n\n　　CMake 对象库可用于保持生成目录不那么混乱，并加快生成过程。 Makefile 的传统工作流程是使用相关的编译选项、定义和链接标志创建大量对象文件（目标）。 然后，最终的可执行文件或库目标将从所有目标文件链接。\n\n　　CMake add_library（） 默认为创建静态库。 以下节创建“libfoo.a”或类似内容：\n\n　　add_library(foo src.f90)\n\n　　对于众多目标，有很多“lib*.a”可能会使构建目录混乱。 此外，从目标文件创建所有这些存档 .a 文件所消耗的时间是有限的。 对于使用 Visual Studio 的项目，使用对象库有助于避免为 MSVC 导出符号时出现复杂情况。\n\n　　CMake 对象库：对于大多数不需要“lib*.a”工件的情况，一个更简洁的选择是改为创建 CMake 对象库：\n\n　　add_library(foo OBJECT src1.f90 src2.f90)\n\n　　add_library(bar OBJECT src3.c src4.c)\n\n　　add_executable(baz main.cpp $<TARGET_OBJECTS:foo> $<TARGET_OBJECTS:bar>)\n\n　　而不是像“libfoo.a，libbar.a”这样的build/文件，只有“baz.exe”。 目标文件将隐藏在 和 下。 生成器表达式扩展到“foo”和“bar”的所有对象文件，就像遗留的Makefile一样。build/CMakeFiles/foo/*.obuild/CMakeFiles/bar/*.o\n\n　　对象库的 INTERFACE 目标属性像往常一样向上传播到链接它们的目标。 从静态或共享库转到对象库时，您可能需要修改对象库的公共/私有/接口，或将它们添加到顶级目标的“target_link_libraries（）”中。\n\n　　警告：具有重复符号的对象库可能会导致需要手动解决的冲突。 链接非对象库时，链接器通常只使用符号的第一个实例。","edit_time_ms":1697984477455,"snapshots":[{"id":"01hdc3j16cercw347a4je343ae","item_id":"01hdbw3zrbd2d0gtshpekg217d","add_time_ms":1697992213708,"hash":"901f728afc12275e9cb67ef28e508d2f","length":881,"char_count_char_with_spaces":859,"char_count_char_without_spaces":798,"char_count_word":469}]}